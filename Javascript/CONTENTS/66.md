## 工厂模式

> 工厂模式定义一个用于创建对象的接口，这个接口由子类决定实例化哪一个类。该模式使一个类的实例化延迟到了子类。而子类可以重写接口方法以便创建的时候制定自己的对象类型(抽象工厂)

## 工厂模式的作用

- 对象的构建十分复杂
- 需要依赖具体的环境创建不同的实例
- 处理大量具有相同属性的小对象

## 工厂模式的注意事项

- 不能滥用工厂，仅仅会给代码增加复杂度

## 工厂模式的实现

简单工厂的实现

```javascript
// 工厂对象
var factory = {};
factory.createClothes = function(){
  this.workers = 30;
  console.log('clothes ok');
};
factory.createShoes = function(){
  this.workers = 100;
  console.log('shoes ok');
};
factory.transport = function () {
  this.cars = 5;
  console.log('transport ok');
}

// 工程中的厂长
factory.director = function (params) {
  // 厂长发布命令去造一条生产线或运输线
  return new factory[params]();
}

var transportStuff = factory.director('transport');
console.log(transportStuff.cars); // 5

```

抽象工厂的实现

```javascript
// 抽象工厂的实现 打个比方：大厂
var AbstractFactory = function(){};
AbstractFactory.prototype = {
  // 在这个工厂中不干什么事，只定义接口(规范)而不实现    
  createFactory:function() {
    throw new Error('This is an abstract method');
  }
}

// 子类的小厂 
var SmallFactory = function () {
  AbstractFactory.call(this);
}
// 这里继承父类
SmallFactory.prototype = new AbstractFactory();
SmallFactory.prototype.constructor = SmallFactory; // 将constructor指向自身
// 这里实现父类(抽象工厂)的方法 （父类只定义规范而不实现，由子类实现）
SmallFactory.prototype.createFactory = function () {
  console.log('small');
}

```